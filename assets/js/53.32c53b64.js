(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{364:function(a,e,r){"use strict";r.r(e);var n=r(7),t=Object(n.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[e("img",{attrs:{src:"https://b3logfile.com/bing/20191017.jpg?imageView2/1/w/960/h/540/interlace/1/q/100",alt:""}})]),a._v(" "),e("h4",{attrs:{id:"yarn主要由四个重要角色组成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#yarn主要由四个重要角色组成"}},[a._v("#")]),a._v(" Yarn主要由四个重要角色组成")]),a._v(" "),e("p",[a._v("ResourceManager：顾名思义资源管理器，主要负责资源管理和调度，ResourceManager主要由两个组件构成：ApplicationManager,主要负责两类工作：1.管理监控各个系统的应用，包括启动\t\t\tApplicaiton Master，监控Applicaiton Master运行状态 2.跟踪分配给Application Master的进度和状态。Scheduler，主要负责分配Container给Applicaiton Master，分配算法有多种（如公平调度等等）可以根据需求不同选择适合的调度策略。\nNodeManager：节点管理器，主要负责维护本节点的资源情况和任务管理。首先NodeManager需要定期向ResourceManager汇报本节点资源使用情况，以便ResourceManager，根据资源使用情况，来分配资源给Application Master，其次，需要管理Applicaiton Master提交来的task，比如接收Applicaiton Master：启动或停止task的请求(启动和停止有NodeManager的组ContainersLanuncher完成)。\nApplicaitonMaster：用户提交的每个program都会对应一个ApplicationMaster，主要负责监控应用，任务容错（重启失败的task）等。它同时会和ResourceManager和NodeManager有交互ResourceManager申请资源，请求NodeManager启动或提示task\nContainer：容器是资源调度的单位，它是内存、cpu、磁盘、和IO的集合。Application Master会给task分配Container，task只能用分配给它的Container的资源。分配流程为：")]),a._v(" "),e("p",[a._v("Resource Manager ->Application Master -> task")]),a._v(" "),e("h4",{attrs:{id:"yarn调度主要步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#yarn调度主要步骤"}},[a._v("#")]),a._v(" Yarn调度主要步骤")]),a._v(" "),e("p",[a._v("1.有YarnClient提交program信息向ResourceManager，包括（应用代码和应用需要的一切参数和环境信息）")]),a._v(" "),e("p",[a._v("2.ResourceManager收到请求之后，调用Application Master Manager向NodeManager发送请求，申请一个资源（Container），并且要求Container启动ApplicationMaster.")]),a._v(" "),e("p",[a._v("3.ApplicationMaster启动之后，首先注册自己到ResourceManager，然后为自己的Task申请Container，这个过程是轮训的，循环申请资源，ResourceManager收到请求之后，会要求NodeManager分配资源。")]),a._v(" "),e("p",[a._v("4.资源分配完毕之后，Application Master发送请求到NodeManager，启动任务。")]),a._v(" "),e("p",[a._v("5.NodeManager设置Container的运行时环境（jar包，环境变量，任务启动脚本），NodeManager会通过脚本启动任务。")]),a._v(" "),e("p",[a._v("6.启动的过程是由NodeManager的ContainerLauncher负责的，ContainerLauncher完成启动任务的工作。")]),a._v(" "),e("p",[a._v("7.这一步是在作业执行过程中持续发生的，主要包括两类交互，第一，task和Application Master的交互，task会向AM汇报任务状态和进度信息，比如任务启动，停止，状态更新。Applicaiton Master利用这些信息监控task整个执行过程。第二，是NodeManager和ResourceManager的交互，这个过程和任务没有关系，主要是两者之间保持的心跳信息。（状态的变化等等）")]),a._v(" "),e("p",[a._v("8.ApplicationMaster在检测到作业运行完毕之后，Application Master向Resource Manager 删除自己，并且停止自己执行。")]),a._v(" "),e("h4",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),e("p",[a._v("1.NodeManager和ResourceManager组件，主要负责控制整个流程")]),a._v(" "),e("p",[a._v("2.Yarn采用了资源双层调度模型，第一层是Yarn分配资源（Container）给ApplicaitonMaster，这是由Yarn实现的 ，第二层，是ApplicaitonMaster分配资源给task，这是有具体工作引擎实现，这样的好处是将，yarn的调度和应用分隔开，便于yarn和应用实现、优化或升级自己的调度策略。上述内容是Yarn调度的基本过程，从调度过程可以看到，Yarn将资源封装抽象为Container，将应用抽象为Application Master,两个关键模型的抽象，实现了对资源和应用的统一管理，进而实现了调度平台和执行引擎的解耦。至于Application怎么样把Container分配给task，怎么样监控task的执行过程，完全是由执行引擎根据自身特性实现的。充分解耦的好处是，Yarn可以同时部署不同的执行引擎，集群不受限制，并且当一个执行引擎升级的时候，不会影响到别的引擎，这对于生产是至关重要的。并且Yarn提供了多种资源调度模式，以满足不同的生产环境。")])])}),[],!1,null,null,null);e.default=t.exports}}]);